---
title: "#10 Custom Type Declarations and Struct"
author: Brandon Tsai
---

Custom Type
----------------------------------------------------------------

A custom type refers to a type that is created by the user, based on existing built-in types or other custom types. It allows you to define a new type with its own set of characteristics, behaviors, and methods, providing abstraction and encapsulation.

Custom types are defined using the `type` keyword followed by a name and the underlying type on which the custom type is based. Here's an example:

```go
package main

import "fmt"

type decks []string

func main() {
	// Creating variables of custom types
	deck := decks{"Clubs A"}
	deck = append(deck, "Diamonds K")

	// Accessing and using variables of custom types
	fmt.Println("Card 0:", deck[0])
	fmt.Println("Card 1:", deck[1])
}

```

Method (Receiver Function)
----------------------------------------------------------------

Technically, Go is not an object-oriented programming language. It doesnâ€™t have classes, objects, and inheritance. However, you can define custom tyes with `methods(receiver functions)` as alternative in Go. For exmaple:

decks.go
```go
package main

import "fmt"

// Create a new type of 'deck'
// which is a slice of strings
type decks []string

// 'd' is the copy of the variable of type 'decks'
// that has access to this print() method
func (d decks) print() {

	for _, value := range d {
		fmt.Println(value)
	}
}

// This receiver functions will return a variable of type `decks`
func (d decks) newStandardDeck() decks {
	newDecks := []string{}
	suits := [4]string{"Clubs", "Diamonds", "Hearts", "Spades"}
	ranks := [13]string{"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"}

	for _, s := range suits {
		for _, r := range ranks {
			newDecks = append(newDecks, s+" "+r)
		}
	}
	return newDecks
}


```

main.go
```go
package main

func main() {
	deck := decks{}
	deck = deck.newStandardDeck()
	deck.print()
}
```

### Cannot Define Methods For Built-in Types


In Go, you cannot define methods directly on built-in types such as string. However, you can achieve similar functionality by creating a new named type using the built-in type as its underlying type, and then defining methods on that named type. For example:

```go
package main

import "fmt"

// Named type based on string
type MyString string

// Method declaration for MyString type
func (s MyString) countChars() int {
	return len(s)
}

func main() {
	// Creating an instance of MyString
	myStr := MyString("Hello, World!")

	// Calling the method on the MyString instance
	charCount := myStr.countChars()

	fmt.Println("Character Count:", charCount)
}

```

By creating a named type and defining methods on it, you can effectively add behavior to built-in types like string in Go. This approach allows you to encapsulate functionality and promote code organization and reusability.


Struct
-------

A struct is a user-defined type which contains values with same or different data types that are related together.
For example, we can define a struct `Card` to reprecent a card in a standard deck.

```go
// Create a new type call Card
type card struct {
	suit string
	rank string
}

// Create a new type of 'deck'
// which is a slice of card
type decks []card

// 'd' is the copy of the variable of type 'decks'
// that has access to this NewStandardDeck() method
func (d decks) newStandardDeck() decks {
	newDecks := []card{}
	suits := [4]string{"Clubs", "Diamonds", "Hearts", "Spades"}
	ranks := [13]string{"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"}

	for _, s := range suits {
		for _, r := range ranks {

			// you can initial card via "card{suit: s, rank: r}" as well
			newDecks = append(newDecks, card{s, r})
		}
	}
	return newDecks
}

func (d decks) print() {
	for _, value := range d {
		fmt.Println(value.suit, value.rank)
	}
}

func (d decks) printWithField() {
	for _, value := range d {
		fmt.Printf("%+v\n", value)
	}
}


```

We can use struct in a struct as well. 

```go

type contactInfo struct {
	phone string
	email string
}

type player struct {
	name    string
	coins   int
	contact contactInfo
}

func main() {
	player1 := player{name: "Brandon", coins: 1000}
	player1.contact = contactInfo{"0987123456", "1989@TS64.com"}

	player2 := player1

	fmt.Printf("%+v\n", player1)
}

```


### Comparation Between Variables of Same Struct

Because Go does not support overloading of methods and operators, you have to implement function for comparing two variables of same struct.

```go

type contactInfo struct {
	phone string
	email string
}

type player struct {
	name    string
	coins   int
	contact contactInfo
}

func (a player) isRicherThan(b player) bool {
	if a.coins > b.coins {
		return true
	}
	return false
}

func main() {

	player1 := player{name: "Brandon", coins: 5000}
	player2 := player{name: "Mark", coins: 1000}

	if player1.isRicherThan(player2) {
		fmt.Printf("%s has more coins.\n", player1.name)
	}

	if !player2.isRicherThan(player1) {
		fmt.Printf("%s has less coins.\n", player2.name)
	}
}

```


### Structs Are Pass By Reference
When you assign one struct variable to another, a new copy of the struct is created and assigned. For example:


```go
player1 := player{name: "Brandon", coins: 1000}
player1.contact = contactInfo{"0987123456", "1989@TS64.com"}

player2 := player1
player2.name = "Kobe"

fmt.Printf("%s\n", player1.name) // output = Brandon
fmt.Printf("%s\n", player2.name) // output = Kobe
```

### Copy struct with slice element properly

Please Refer https://waclawthedev.medium.com/golang-trap-how-to-copy-structs-properly-9cb2dd4c0832


When copying a struct variable with a slice element in Go, it's important to consider the underlying data referenced by the slice. By default, assigning or copying a struct variable only creates a shallow copy, where the new variable points to the same underlying slice data. Modifying the original or copied struct's slice will affect both variables. To make a proper copy with an independent slice, you need to create a new slice and copy the elements from the original slice. Here's an example:

```go
package main

import (
	"fmt"
	"reflect"
)

type accessControl struct {
	role  string
	users []string
}

func main() {
	// Original struct variable
	original := accessControl{
		role:  "admin",
		users: []string{"user1", "user2", "user3"},
	}

	// Copying the struct variable
	copied := original
	fmt.Println("Original:", original)
	fmt.Println("Copied:", copied)

	// Modifying the original struct's slice
	original.users[0] = "newUser"
	fmt.Println("Original after modification:", original)
	fmt.Println("Copied after modification:", copied)

	// Creating a deep copy of the struct variable
	deepCopied := accessControl{
		role:  copied.role,
		users: make([]string, len(copied.users)),
	}
	copy(deepCopied.users, copied.users)

	// Modifying the deep copied struct's slice
	deepCopied.users[0] = "newUser2"
	fmt.Println("Deep Copied:", deepCopied)
	fmt.Println("Copied after deep copy modification:", copied)

	// Comparing the original and copied struct variables
	fmt.Println("Original and Copied are equal?", reflect.DeepEqual(original, copied))

	// Comparing the original and deep copied struct variables
	fmt.Println("Original and Deep Copied are equal?", reflect.DeepEqual(original, deepCopied))
}

```

In this example, we have the `accessControl` struct with two fields: `role` (string) and `users` (slice of strings). We first create the original struct variable with some initial data.

When we assign the original struct to the copied struct using copied := original, it creates a shallow copy where both variables share the same underlying slice data. Modifying the original.users slice will also reflect in the copied.users slice.

To create a deep copy with an independent slice, we manually create a new deepCopied struct variable and copy the role field value. Then, we use the make() function to create a new slice with the same length as the copied.users slice, and finally, we use the copy() function to copy the elements from copied.users to deepCopied.users. This ensures that the deepCopied.users slice is completely independent from the copied.users slice.

Modifying the deepCopied.users slice will not affect the copied.users slice.

We use the reflect.DeepEqual() function to compare the original and copied structs. The result will be true for the shallow copy and false for the deep copy, as the deep copy creates a struct with an independent slice.

By properly creating a deep copy, you can ensure that the struct variables have independent slices and modifications to one do not affect the other.